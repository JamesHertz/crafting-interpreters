/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package jh.craft.interpreter;

import jh.craft.interpreter.core.Interpreter;
import jh.craft.interpreter.core.Parser;
import jh.craft.interpreter.errors.ParsingError;
import jh.craft.interpreter.representation.AstPrinter;
import jh.craft.interpreter.representation.Expr;
import jh.craft.interpreter.scanner.Scanner;
import jh.craft.interpreter.utils.Utils;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;

public class Main {
    public static void main(String[] args) {

        if( args.length == 0)
            runPrompt();
        else if( args.length == 1 )
            runFile( args[0] );
        else  {
            System.err.println("usage: jlox <filename>");
            System.exit(1);
        }

    }

    private static void runPrompt(){
        BufferedReader reader = new BufferedReader(
                new InputStreamReader( System.in )
        );

        String line = null;
        try {
            for(;;){
                System.out.print("> ");
                line = reader.readLine();
                if( line == null) break;
                run(line);
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private static void runFile(String filename){
        try {
            var source = Files.readString(Path.of(filename));
            run( source );
        } catch (IOException e) {
            System.out.printf(
                    "Error reading '%s': %s\n", filename, e.getMessage()
            );
            System.exit(1);
        }

    }


    private static void run(String text){
        var res = Scanner.scanTokens(text);

        if(!res.isOk()){
            Main.error( res.error(), text );
            return;
        }

        var tokens = res.value();
        tokens.forEach(
                token -> System.out.println("-> " + token)
        );

        var expr = Parser.parse( tokens );
        if( !expr.isOk() ){
            Main.error( expr.error(), text );
            return;
        }
        System.out.println(
                new AstPrinter().print( expr.value() )
        );

        var aux = Interpreter.evaluate( expr.value() );
        if( aux.isOk() )
            System.out.println( Utils.stringify(aux) );
        else
            Main.error( aux.error(), text );

    }



    public static void error(ParsingError error, String source){
        int lineStart = error.position();
        int lineEnd   = lineStart + 1;

        while( lineStart >= 0 && source.charAt( lineStart ) != '\n')
            lineStart--;

        while( lineEnd < source.length() && source.charAt( lineEnd ) != '\n')
            lineEnd++;


        // Building the errLine (
        //     The one that will have the line
        //     number and the line from the source code.
        // )
        String indication = String.format("\t %d | ", error.line());
        String errLine   =  indication + source.substring(lineStart + 1, lineEnd);

        // Calculating the number of spaces needed for ^ to be right below
        // the character where the error happened
        int errOffset = error.position() - lineStart + indication.length() - 2;
        String spaces = String.format("\t%" + errOffset + "s", "");

        // Building the final String ...
        System.out.printf("Error: %s: \n%s\n%s^-- Here.\n", error.msg(), errLine, spaces);
    }

}
